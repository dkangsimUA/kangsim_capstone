---
title: "MSDS_Captsone_piepline"
author: "Eastern Kang"
format: html
editor: visual
---

```{r}
pacman::p_load(here, fs, glue, 
               qualtRics, openxlsx, 
               tidyverse, readxl)
```

## Qualtrics API & wrangling

Based on the diagram, the pipeline starts when the Local Experts (`experts`) fills out the consent form. Once `experts` are eligible, next step of the pipeline is the `custom survey generation`.

In order to customize surveys by *geographical location*, we need to access `experts` location information. We can fetch these location information from the Qualtrics server where the consent form was distributed and results are saved.

Thus, the first step of the R script would be establishing connection between a local machine to the Qualtrics server. The `api_key` can be found from the `account settings` --\> `qualtrics ids` --\> `API token`

```{r add a script for linking Qualtrics}
#Register your credential
#This step needs to be done only once
qualtRics::qualtrics_api_credentials(
  api_key = "ngZZK8IxIeJiOs8Y5U6FtbYoeJbkk4CjofJkGGYu",
  base_url = "uarizona.iad1.qualtrics.com",
  install = TRUE,
  overwrite=TRUE)
```

Once the `api_key` is registered to the local machine, we can **fetch** survey by using the `fetch_survey` function. The `fetch_survey` function is from the `QualtRics` package, which is a function that communicates with the Qualtrics API based on the Survey ID. The unique Survey ID can be retrieved from the Qualtrics User Portal.

```{r}
#download the survey results
fetch_survey(surveyID= "SV_7ZCxh3OmFBpFWu2", 
             #start_date = "YYYY-MM-DD", 
             #Default NULL
             #end_date = "YYYY-MM-DD", 
             #Default NULL
             #limit=integer, 
             #maximum number of responses
             breakout_sets = FALSE,
             add_var_labels = FALSE) %>% 
  filter(Finished == TRUE) %>%  
  # Filters out in-progress surveys
  write_csv( # save survey results 
    file = here("1_registration_survey_output",
                "1_survey_results",
                glue("MEX_registration_output_{Sys.Date()}.csv")),
    na = "")
```

On a side note: The `QualtRics` package has some functions that may be used for retrieving a list of surveys, or by survey ID.

```{r optional}
# Retrieve a list of surveys
surveys <- all_surveys() # retrieve a data frame of all active surveys on Qualtrics

# Retrieve surveyID for a unique survey
my_id <- fetch_id(surveys, "Unique Survey Name")

# Retrieve surveyID for a unique survey
# a<-fetch_distributions("SV_7ZCxh3OmFBpFWu2")
# you can also fetch_distribution_history; this may be useful for confirming generated surveys are properly distributed

```

Once surveys are fetched, we can use the newest survey results by getting a list of files, sort it in descending order, and grab the first object using the following code:

```{r}
# list all survey results
files_csv <- list.files(path= "name-of-the-file-directory")

# retrieve the newest registration survey
files_csv2<- files_csv%>%
  as_tibble()%>%
  dplyr::filter(str_detect(value, "^MEX_"))%>%
  arrange(desc(value))%>%
  as.list()

newest_MEX<- files_csv2$value[1]

```

The survey customization is based on the `experts` location. In this example, Mexico has `dept` (Estado) and `mun`. We would use the information from the `experts` registration form and *`glue`* the strings together.

The following script presents a simple wrangling process for filtering `experts` who consented and generates the `surveyname` required for customization.

```{r}
MEX <- read_csv(here("../quaderno/kangsim_capstone/data_output/MEX_registration_output_sample.csv"))%>%
  mutate(across(starts_with("Q7."), 
                as.character),
         across(starts_with("Q8."), 
                as.character))%>%
  MEX_wrangle()%>% #custom function
  dplyr::select(EndDate, ResponseId, name, 
                email, phone, phone_company, 
                exp, industry, citizen, 
                dept= Q6.2, mun)#%>%
  filter(!is.na(dept),
         !is.na(mun))%>% #remove empty responses
  mutate(drupal_surveyname = 
           glue("{mun} en {dept}"),
         phone = ifelse(is.na(phone), "Declined", phone))
```

The `drupal_surveyname` created above will be used for customizing the survey.

## Survey generation

Once `drupal_surveyname` has been created, we can create a customized version of survey based on **respondent name** and **municipality of expertise**.

Let's load survey questionnaires. Sample Qualtrics Survey File (**QSF)** file has been provided for the demonstration.

```{r}
svy.2 <- read_file (here(
  "2_governance_survey_generation",
  "1_original_gov_qsf_files",
  "2_MEX_ESP_Governance_s24.qsf"))

#create a variable for the new survey name
name.svy <- "MEX s2.4"
```

We would need to download the responses file, then generate `locations` per respondent

```{r}
#download the responses file
MEX_responses<- read_csv(here(
  "1_registration_survey_output", 
  "1_survey_results", 
  newest_MEX), na="")%>% 
  #load the newest survey result
  mutate(across(starts_with("Q7."), 
                as.character),
         across(starts_with("Q8."), 
                as.character))

#generate location

locations<- MEX_responses %>%
  MEX_wrangle() %>% #refer to `MEX_wrangle_provinces.R`
  dplyr::select(
    ResponseId, EndDate, 
    name, email, lang, 
    dept=Q6.2, mun)%>%
  mutate(ResponseId = 
           factor(ResponseId),
         ResponseId = 
           fct_reorder(ResponseId, EndDate))%>% 
  group_by(ResponseId)%>%
  mutate(id = cur_group_id(), 
         #unique ID per respondent
         id= str_pad(id, 5, pad="0"), 
         #generate zeros
         counter = str_pad(row_number(), 
                           4, 
                           pad="0"))%>% #generate counter per location
  ungroup()%>% 
  relocate(ResposneID, id, 
           counter, dept, mun)%>%
  filter(!is.na(dept),
         !is.na(mun))%>%
  mutate(name.svy.id = glue("{name.svy}_{id}_{counter}"),
         drupal_surveyname = glue("{mun} en {dept}"))# create survey name
```

The following script generates individualized surveys:

```{r}
#crates the *.QSF file in a new column
surveys <- locations%>%
  mutate(survey = svy.2, 
         #a copy of survey for each row
         #insert mun name into the survey
         survey = str_replace(
           survey, "Mun-1", 
           glue("{mun} en {dept}")), 
         #insert id into survey name
         survey = str_replace(
           survey, "2 MEX ESP Governance s2.4",
           name.svy.id))%>%
  ungroup()

#create a new folder to place surveys in
dir.crate(here("2_governance_survey_generation",
               "3_generated_gov_qusf_files",
               Sys.Date()))

#create the survey in *.QSF format and save it in the folder 

surveys %>%
  select(survey, name.svy.id)%>%
  purrr::pwalk(function (survey, name.svy.id){
    write_file(
      survey, #save the survey
      here(
        "2_governance_survey_generation",
        "3_generated_gov_qsf_files",
        Sys.Date(),
        glue("{name.svy.id}.qsf")
      ))
  })
```

## Survey uploads

Once the custom survey has been generated and saved in Qualtrics Survey Format form, we can upload the survey files to Qualtrics Server via Qualtrics API.

In order to communicate with the Qualtrics API, we need to configure basic information required for the script to communicate with API and also directs the newest file name.

By incorporating the information in R, the script updates the JSON file with the latest information.

See a sample script below:

```{r}
json_data<- read_json(here("survey_upload/qualtricsSurveyConfig.json"))

#specify apiToken:
json_data$apiToken<- "<insert token info>"
json_data$apiDatacenterID <- "iad1"
json_data$apiLibraryID <- "<insert library ID>"

#declare the folder with all the QSF files
json_data$qsfFileLocation<- 
  glue("<file directory>")

#newest survey name
json_data$importSurveyInputCSV<- 
  glue("<file directory of newest surveylist>")

#indicate the new file to store the Qualtrics meata data of the uploaded surveys
json_data$uploadSurveyScriptOutputCSV<- 
  glue("<file directory>/result-survey-upload_{Sys.Date()}.csv")

#indicate the new file to store the Qualtrics meta data of the assigned Qualtrcis surveys
json_data$assignSurveyScriptOutputCSV <- 
  glue("<file directory>/result-survey_assignment_{Sys.Date()}.csv")

#save over the json file with current information
json_data %>%
  as_tibble%>%
  toJSON(pretty=TRUE)%>%
  str_remove("\\[")%>% #[] is an array and we do not want that
  str_remove("\\]")%>%
  write_file("<file directory>/qualtricsSurveyConfig.json")
```

At the time of preparing this manuscript, Python is the supported programming language for communicating with Qualtrics API. The `qualtRics` package from R does not support the uploading survey function.

We use R's `reticulate` package to install Python and run in the same Rstudio IDE. This needs to be done only once. The `reticulate::py_config()` function is one of the simplest way of installing python on your local machine.

```{r}
remotes::install_github("rstudio/reticulate")
reticulate::py_config()
py_install("requests")
```

### Python scripts

We present the `source` function to call our Python scripts into R first, and then present the Python script later. The `source` function makes running script efficient and easy by calling a outside programming scripts into R.

```{r}
source_python(here("<file directory>/upload_surveys.py"))
```

```{python}
#set up
import os
import csv
import json
import requests # we installed this in R

strConfigFileLocation = "./<file directory/qualtricsSurveyConfig.json"

with open(strConfigFileLocation, encoding="utf8", errors="ignore") as fileConfig:
  objConfig=json.load(fileConfig)
  
strAPIToken = objConfig["apiToken"]
strDatacenter = objConfig["apiDatacenterID"]
strCSVFileLocation =
objConfig["importSurveyInputCSV"]
strCSVOutputFileLocation=objConfig["<file location>"]
strSurveyFileLocation = objConfig["qsfFileLocation"]
```

The following Python script establishes connection between local machine and Qualtrics API to upload QSF files to the server based on the JSON configuration information provided above.

```{python}
intIndexColumn = 0
intIndexRow = 0
listFilesToPush = []
dictFilesToPush = {}
dictFileMetaData = {}
dictFilesRecorded = {}
strFileToPushIndex = ""
listDataOutput = [["email", "filename", "name",
                  "listName", "listCategory", 
                  "distributionDescription", 
                  "shareIDs", 
                  "qualtricsSurveyID"]]
dictColumnXRef = {}

strBaseURL = "https://" + strDatacenter + ".qualtrics.com/API/v3/surveys"

dictHeaders = { "x-api-token": strAPIToken }

dictShareHeaders = { "X-API-TOKEN": strAPIToken, "Content-Type": "application/json" }

with open(strCSVFileLocation, encoding="utf8", errors="ignore") as fileDataInput:
	csvReaderFileDataInput = csv.reader(fileDataInput, delimiter=',')
	for listRowData in csvReaderFileDataInput:
		if (intIndexRow > 0):
			if (listRowData[dictColumnXRef["filename"]] in dictFilesToPush):
				dictFilesToPush[listRowData[dictColumnXRef["filename"]]]["emails"].append(listRowData[dictColumnXRef["email"]])
			else:
				dictFilesToPush[listRowData[dictColumnXRef["filename"]]] = { "emails": [listRowData[dictColumnXRef["email"]]], "filename" : listRowData[dictColumnXRef["filename"]], "name": listRowData[dictColumnXRef["name"]], "listName": listRowData[dictColumnXRef["listName"]], "listCategory": listRowData[dictColumnXRef["listCategory"]], "distributionDescription": listRowData[dictColumnXRef["distributionDescription"]], "shareIDs": listRowData[dictColumnXRef["shareIDs"]], "qualtricsSurveyID": "" }
		else:
			for strColumnName in listRowData:
				dictColumnXRef[strColumnName] = intIndexColumn
				intIndexColumn = intIndexColumn + 1

		intIndexRow = intIndexRow + 1

listFilesToPush = dictFilesToPush.keys()

for strFileToPushIndex in listFilesToPush:
	dictFiles = {
		'file': (
			dictFilesToPush[strFileToPushIndex]["filename"],
			open((strSurveyFileLocation + dictFilesToPush[strFileToPushIndex]["filename"]), 'rb'),
			'application/vnd.qualtrics.survey.qsf'
		)
	}

	dictData = {
		"name": dictFilesToPush[strFileToPushIndex]["name"]
	}

	resResponse = requests.post(strBaseURL, files=dictFiles, data=dictData, headers=dictHeaders)
	dictResponse = resResponse.json()
	if (dictResponse["meta"]["httpStatus"] == "200 - OK"):
		dictFilesToPush[strFileToPushIndex]["QualtricsID"] = dictResponse["result"]["id"]
		for strEmail in dictFilesToPush[strFileToPushIndex]["emails"]:
			listDataOutput.append([strEmail, dictFilesToPush[strFileToPushIndex]["filename"], dictFilesToPush[strFileToPushIndex]["name"], dictFilesToPush[strFileToPushIndex]["listName"], dictFilesToPush[strFileToPushIndex]["listCategory"], dictFilesToPush[strFileToPushIndex]["distributionDescription"], listRowData[dictColumnXRef["shareIDs"]], dictResponse["result"]["id"]])
		print("Successfully sent " + dictFilesToPush[strFileToPushIndex]["name"] + " (" + dictFilesToPush[strFileToPushIndex]["filename"] + ") to Qualtrics (surveyID: " + dictResponse["result"]["id"] + ")")

		strShareSurveyURL = "https://" + strDatacenter + ".qualtrics.com/API/v3/surveys/" + dictResponse["result"]["id"] + "/permissions/collaborations"
		listToShare = dictFilesToPush[strFileToPushIndex]["shareIDs"].split("|")

		for strShareID in listToShare:
			dictShareData = {
				"recipientId": strShareID,
				"permissions": {
					"surveyDefinitionManipulation": {
						"copySurveyQuestions": True,
						"editSurveyFlow": True,
						"useBlocks": True,
						"useSkipLogic": True,
						"useConjoint": True,
						"useTriggers": True,
						"useQuotas": True,
						"setSurveyOptions": True,
						"editQuestions": True,
						"deleteSurveyQuestions": True,
						"useTableOfContents": True,
						"useAdvancedQuotas": True
					},
					"surveyManagement": {
						"editSurveys": True,
						"activateSurveys": True,
						"deactivateSurveys": True,
						"copySurveys": True,
						"distributeSurveys": True,
						"deleteSurveys": True,
						"translateSurveys": True
					},
					"response": {
						"editSurveyResponses": True,
						"createResponseSets": True,
						"viewResponseId": True,
						"useCrossTabs": True,
						"useScreenouts": True
					},
					"result": {
						"downloadSurveyResults": True,
						"viewSurveyResults": True,
						"filterSurveyResults": True,
						"viewPersonalData": True
					}
				}
			}

			strShareData = json.dumps(dictShareData)
			resShareResponse = requests.post(strShareSurveyURL, data=strShareData, headers=dictShareHeaders)
			dictShareResponse = resShareResponse.json()
	else:
		print(">>>Failed to send " + dictFilesToPush[strFileToPushIndex]["name"] + " (" + dictFilesToPush[strFileToPushIndex]["filename"] + ") to Qualtrics")

if (len(listDataOutput) > 1):
	rscCSVOutputFile = open(strCSVOutputFileLocation, 'w+', newline ='')

	with rscCSVOutputFile:
		csvWriterFileDataOutput = csv.writer(rscCSVOutputFile, delimiter=',')
		csvWriterFileDataOutput.writerows(listDataOutput)
```

The second Python scripts assigns the qualtrics surveys to the right experts.

```{python}
from genericpath import isfile
import os
import csv
import json
import requests

def find_file(file_name, directory_name):
    files_found = []
    for path, subdirs, files in os.walk(directory_name):
        for name in files:
            if(file_name == name):
                file_path = os.path.join(path,name)
                files_found.append(file_path)
    return files_found
find_file('qualtricsSurveyConfig.json', '3_qualtrics_survey_upload')


strConfigFileLocation = "./3_qualtrics_survey_upload/qualtricsSurveyConfig.json"

with open(strConfigFileLocation) as fileConfig:
	objConfig = json.load(fileConfig)

strAPIToken = objConfig["apiToken"]
strDatacenter = objConfig["apiDatacenterID"]
strTargetLibraryID = objConfig["apiLibraryID"]
strCSVFileLocation = objConfig["importSurveyInputCSV"]
strCSVInputFileLocation = objConfig["uploadSurveyScriptOutputCSV"]
strCSVOutputFileLocation = objConfig["assignSurveyScriptOutputCSV"]

##################################################################################################################
##################################################################################################################

dictHeaders = { "x-api-token": strAPIToken, 'Content-Type': "application/json" }
strAddEmailToMailListURL = "https://"+ strDatacenter + ".qualtrics.com/API/v3/mailinglists/"
strCreateDistURL = "https://"+ strDatacenter + ".qualtrics.com/API/v3/distributions"
listOutputCSV = [["email", "filename", "name", "listName", "listCategory", "distributionDescription", "shareIDs", "qualtricsSurveyID", "qualtricsContactID", "qualtricsEmailListID", "qualtricsDistID", "qualtricsSurveyURL"]]
intIndexRow = 0
intIndexColumn = 0
dictColumnXRef = {}
strColumnName = ""
listOutputRow = []
dictCurrentRow = {}

#
# Create mailing lists for each CSV row (address)
def createMailingList(strListName = "", strlibraryID = "", strListCategory = "", strDatacenter = "", dictHeaders = {}):
	strURL = "https://" + strDatacenter + ".qualtrics.com/API/v3/mailinglists"
	dictReturn = {}

	dictData = {
		"name": strListName,
		"libraryId": strlibraryID,
		"category": strListCategory
	}

	strJSONData = json.dumps(dictData)
	resResponse = requests.post(strURL, data=strJSONData, headers=dictHeaders)
	dictResponse = resResponse.json()

	if (dictResponse["meta"]["httpStatus"] == "200 - OK"):
		dictReturn = {"status" : "200", "qualtricsEmailListID" : dictResponse["result"]["id"]}
#		strReturn = dictResponse["result"]["id"]
	else:
		dictReturn = { "status" : dictResponse["meta"]["httpStatus"], "error" : dictResponse["meta"]["error"]["errorMessage"] }

	return dictReturn

#
# Assign email address to a mailing list
def assignMailingList(strEmail = "", strListID = "", strDatacenter = "", dictHeaders = {}):
	strURL = "https://"+ strDatacenter + ".qualtrics.com/API/v3/mailinglists/" + strListID + "/contacts"
	dictReturn = {}

	dictData = {
		"email":strEmail,
		"unsubscribed": False
	}
	strJSONData = json.dumps(dictData)

	resResponse = requests.post(strURL, data=strJSONData, headers=dictHeaders)
	dictResponse = resResponse.json()

	if (dictResponse["meta"]["httpStatus"] == "200 - OK"):
		dictReturn = { "status" : "200", "qualtricsContactID" : dictResponse["result"]["id"] }
	else:
		dictReturn = { "status" : dictResponse["meta"]["httpStatus"], "error" : dictResponse["meta"]["error"]["errorMessage"] }

	return dictReturn

#
# Activate survey
def activateSurvey(strSurveyID = "", strDatacenter = "", dictHeaders = {}):
	dictReturn = {}
	strURL = "https://"+ strDatacenter + ".qualtrics.com/API/v3/surveys/" + strSurveyID

	dictData = {
		"isActive": True,
	}

	strJSONData = json.dumps(dictData)

	resResponse = requests.put(strURL, data=strJSONData, headers=dictHeaders)
	dictResponse = resResponse.json()

	if (dictResponse["meta"]["httpStatus"] == "200 - OK"):
		dictReturn = { "status" : "200" }
	else:
		dictReturn = { "status" : dictResponse["meta"]["httpStatus"], "notice" : dictResponse["meta"]["notice"] }

	return dictReturn

#
# Create survey distribution
def createDistribution(strSurveyID = "", strDistributionDescription = "", strListID = "", strDatacenter = "", dictHeaders = {}):
	dictReturn = {}
	strURL = "https://"+ strDatacenter + ".qualtrics.com/API/v3/distributions"

	dictData = {
		"surveyId": strSurveyID,
		"linkType": "Individual",
		"description": strDistributionDescription,
		"action": "CreateDistribution",
#		"expirationDate": "2020-10-24 00:00:00",
		"mailingListId": strListID
	}

	strJSONData = json.dumps(dictData)
	resResponse = requests.post(strURL, data=strJSONData, headers=dictHeaders)
	dictResponse = resResponse.json()
	if (dictResponse["meta"]["httpStatus"] == "200 - OK"):
		dictReturn = { "status" : "200", "qualtricsDistID" : dictResponse["result"]["id"] }
	else:
		dictReturn = { "status" : dictResponse["meta"]["httpStatus"], "error" : dictResponse["meta"]["error"]["errorMessage"] }

	return dictReturn

#
# Get link and data from survey
def getSurveyLink(strDistributionID = "", strSurveyID = "", strDatacenter = "", dictHeaders = {}):
	dictReturn = {}
	strURL = "https://"+ strDatacenter + ".qualtrics.com/API/v3/distributions" + "/" + strDistributionID + "/links"
	dictParameters = { "surveyId" : strSurveyID }

	resResponse = requests.get(strURL, params=dictParameters, headers=dictHeaders)
	dictResponse = resResponse.json()

	if (dictResponse["meta"]["httpStatus"] == "200 - OK"):
		dictReturn = { "status" : "200", "qualtricsSurveyURL" : dictResponse["result"]["elements"][0]["link"], "email": dictResponse["result"]["elements"][0]["email"] }
	else:
		dictReturn = { "status" : dictResponse["meta"]["httpStatus"], "error" : dictResponse["meta"]["error"]["errorMessage"] }

	return dictReturn


with open(strCSVInputFileLocation) as fileDataInput:
	csvReaderFileDataInput = csv.reader(fileDataInput, delimiter=',')

	for listRowData in csvReaderFileDataInput:
		if (intIndexRow == 0):
			for strColumnName in listRowData:
				dictColumnXRef[strColumnName] = intIndexColumn
				intIndexColumn = intIndexColumn + 1
		else:
			for strColumnName in listOutputCSV[0]:
				if (strColumnName in dictColumnXRef):
					dictCurrentRow[strColumnName] = listRowData[dictColumnXRef[strColumnName]]
				else:
					dictCurrentRow[strColumnName] = ""
# 			Create mailing lists for each CSV row (address)
			dictResponse = createMailingList(dictCurrentRow["listName"], strTargetLibraryID, dictCurrentRow["listCategory"], strDatacenter, dictHeaders)
			if (dictResponse["status"] == "200"):
				strCurrentEmailListID = dictResponse["qualtricsEmailListID"]
				dictCurrentRow["qualtricsEmailListID"] = dictResponse["qualtricsEmailListID"]
#				Add target email address to the mailing list we just created
				dictResponse = assignMailingList(dictCurrentRow["email"], strCurrentEmailListID, strDatacenter, dictHeaders)
				if (dictResponse["status"] == "200"):
					strCurrentContactID = dictResponse["qualtricsContactID"]
					dictCurrentRow["qualtricsContactID"] = dictResponse["qualtricsContactID"]
#					activate survey (we can't assign a distribution until we do so)
					dictResponse = activateSurvey(dictCurrentRow["qualtricsSurveyID"], strDatacenter, dictHeaders)
					if (dictResponse["status"] == "200"):
#						Associate the target survey with the target email address via the mailing list we just created (create distribution)
						dictResponse = createDistribution(dictCurrentRow["qualtricsSurveyID"], dictCurrentRow["distributionDescription"], strCurrentEmailListID, strDatacenter, dictHeaders)
						if (dictResponse["status"] == "200"):
							strCurrentDistID = dictResponse["qualtricsDistID"]
							dictCurrentRow["qualtricsDistID"] = dictResponse["qualtricsDistID"]
#							Get the link of our target survey for the target email address
							dictResponse = getSurveyLink(strCurrentDistID, dictCurrentRow["qualtricsSurveyID"], strDatacenter, dictHeaders)
							if (dictResponse["status"] == "200"):
								dictCurrentRow["qualtricsSurveyURL"] = dictResponse["qualtricsSurveyURL"]
								strSurveyLink = dictResponse["qualtricsSurveyURL"]
								strReturnedEmail = dictResponse["email"]
								listOutputRow = []

								for strColumnName in listOutputCSV[0]:
									listOutputRow.append(dictCurrentRow[strColumnName])

								dictCurrentRow.clear()
								listOutputCSV.append(listOutputRow)
							else:
								print ("step five failed")
								print (dictResponse)
						else:
							print ("step four failed")
							print (dictResponse)
					else:
						print ("step three failed")
						print (dictResponse)
				else:
					print ("step two failed")
					print (dictResponse)
			else:
				print ("step one failed")
				print (dictResponse)

		intIndexRow = intIndexRow + 1

if (len(listOutputCSV) > 1):
	rscCSVOutputFile = open(strCSVOutputFileLocation, 'w+', newline ='')

	with rscCSVOutputFile:
		csvWriterFileDataOutput = csv.writer(rscCSVOutputFile, delimiter=',')
		csvWriterFileDataOutput.writerows(listOutputCSV)

```

Depends on the file size and the number of surveys, it may take a long time time for the function to be finished.

Once the Python scripts ran successfully, we can do a post-Python processing in preparation for Drupal upload

```{r}
#create csv file for Drupal to create accounts and assignign surveys. 
result<- read_csv (here("<file directory>/assign_file"))

#gather respondent's info to creaet accounts
key<- read_csv("<file directory>/resp_key.csv")

###################
# Drupal step 1. Create new accounts
# create delimited survey respondents list to upload in Drupal
result %>% 
  left_join(key, by = c("email", "name" = "name.svy.id")) %>% 
  mutate(name = email) %>% 
  select(name, email, language = lang, timezone) %>% 
  distinct() %>% 
  write_csv(here("4_drupal_upload", # write out survey-respondents-example.csv
                 "1_respondents",
                 glue("survey_respondents_{country_code}_{Sys.Date()}.csv")))


###################
# Drupal step 2. Attaches a survey URL to each user
# Create result-survey-assignment.csv with Drupal survey name (based on location) for display in interface
key %>% 
  select(name.svy.id, drupal_surveyname, email) %>% 
  right_join(result, by = c("email", "name.svy.id" = "name")) %>% 
  filter(!is.na(drupal_surveyname)) %>% 
  mutate(type = "control") %>% 
  select(email, 
         name = drupal_surveyname,
         type, 
         qualtricsContactID, 
         qualtricsSurveyURL) %>% 
  write_csv(here("4_drupal_upload",
                 "2_surveys",
                 glue("result-survey-assignment_{country_code}_{Sys.Date()}.csv")))
```

## Processing completed survey

Once all generating, uploading steps were completed, experts should have received the survey link and time to respond to the custom survey. Once surveys were collected, we can download and process data.
